  <!-- include this in your <head> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

  <script>
    const gpsFeeds = {
      'GPS1': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQLeQeN75y60DLI159llAcz32CYiN0gvFuW5hErLrqp_b2OB5uuaDEfB7CaJFoIOmeuh3dpU9ALeaqc/pub?gid=0&single=true&output=csv',
      'GPS2': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQLeQeN75y60DLI159llAcz32CYiN0gvFuW5hErLrqp_b2OB5uuaDEfB7CaJFoIOmeuh3dpU9ALeaqc/pub?gid=1682085561&single=true&output=csv'
    };
    const lineColors   = { 'GPS1': 'blue',   'GPS2': 'green'  };
    const markerColors = { 'GPS1': 'red',    'GPS2': 'orange' };

    let map, routeLines = {}, markers = {};

    async function loadMapData() {
      try {
        // 1) Fetch & parse each CSV
        const parsed = await Promise.all(
          Object.entries(gpsFeeds).map(([gpsName, url]) =>
            new Promise((resolve, reject) => {
              Papa.parse(url + '&t=' + Date.now(), {
                download:      true,
                header:        true,
                skipEmptyLines:true,
                complete: ({ data }) => {
                  // data is an array of {Timestamp, Latitude, Longitude}
                  console.log(`${gpsName} parsed ${data.length} rows`);
                  resolve({ gpsName, data });
                },
                error: (err) => reject(err)
              });
            })
          )
        );

        // 2) Initialize map on first valid point
        if (!map) {
          const first = parsed.find(p => p.data.length && !isNaN(parseFloat(p.data[0].Latitude)));
          if (!first) {
            console.warn('No valid points yet to initialize map');
            return;
          }
          const lat0 = parseFloat(first.data[0].Latitude),
                lng0 = parseFloat(first.data[0].Longitude);
          map = L.map('map').setView([lat0, lng0], 9);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
          }).addTo(map);
        }

        const allBounds = [];

        // 3) For each feed: clear old layers, then draw
        parsed.forEach(({ gpsName, data }) => {
          // clean up
          if (routeLines[gpsName]) map.removeLayer(routeLines[gpsName]);
          (markers[gpsName]||[]).forEach(m=>map.removeLayer(m));

          // map raw rows to [lat, lng]
          const coords = data
            .map(r => {
              const lat = parseFloat(r.Latitude),
                    lng = parseFloat(r.Longitude);
              return (!isNaN(lat) && !isNaN(lng)) ? [lat, lng] : null;
            })
            .filter(c => c);

          // nothing to draw?
          if (!coords.length) return;

          // if multiple points, draw polyline
          if (coords.length > 1) {
            routeLines[gpsName] = L.polyline(coords, {
              color:   lineColors[gpsName]   || 'black',
              weight:  4,
              opacity: 0.7
            }).addTo(map);
            allBounds.push(routeLines[gpsName].getBounds());
          }

          // always draw markers (at least one)
          markers[gpsName] = coords.map((c, i) =>
            L.circleMarker(c, {
              radius:      4,
              fillColor:   markerColors[gpsName] || 'black',
              color:       '#000',
              weight:      1,
              fillOpacity: 0.8
            })
            .addTo(map)
            .bindTooltip(`${gpsName} taÅ¡kas ${i+1}`)
          );
        });

        // 4) finally, fit map to all lines
        if (allBounds.length) {
          const combined = allBounds.reduce((b, bb) => b.extend(bb), L.latLngBounds());
          map.fitBounds(combined.pad(0.1));
        }
      }
      catch (err) {
        console.error('Klaida kraunant GPS duomenis:', err);
      }
    }

    loadMapData();
    setInterval(loadMapData, 15000);
  </script>
