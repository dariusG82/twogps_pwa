<!DOCTYPE html>
<html lang="lt">
<head>
  <meta charset="UTF-8"/>
  <title>GPS1 & GPS2 maršrutai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS (be SRI) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet JS (be SRI) -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // 1) PDF CSV nuorodos
    const CSV_GPS1 = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQLeQeN75y60DLI159llAcz32CYiN0gvFuW5hErLrqp_b2OB5uuaDEfB7CaJFoIOmeuh3dpU9ALeaqc/pub?gid=0&single=true&output=csv';
    const CSV_GPS2 = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQLeQeN75y60DLI159llAcz32CYiN0gvFuW5hErLrqp_b2OB5uuaDEfB7CaJFoIOmeuh3dpU9ALeaqc/pub?gid=1682085561&single=true&output=csv';
    const MAX_ROWS   = 50;
    const REFRESH_MS = 15000;

    // 2) Init map su minZoom, noWrap ir maxBounds
    const map = L.map('map', {
      minZoom: 3,                    // neleis zoom'inti žemyn žemiau 3
      maxBounds: [[-90,-180],[90,180]]  // nepertraukti vertikalių ribų
    }).setView([55.0, 23.5], 8);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors',
      noWrap: true
    }).addTo(map);

    // 3) Sukuriame vieną kartą polyline'us
    const poly1 = L.polyline([], { color: 'blue' }).addTo(map);
    const poly2 = L.polyline([], { color: 'green' }).addTo(map);

    // 4) Parsinimo funkcija
    function parseCSV(text) {
      return text
        .trim()
        .split('\n')
        .slice(1)
        .map(line =>
          line.split(',').map(cell => cell.replace(/^"|"$/g,'').trim())
        )
        .map(cols => [ parseFloat(cols[1]), parseFloat(cols[2]) ])
        .filter(([lat,lon]) => !isNaN(lat) && !isNaN(lon))
        .slice(-MAX_ROWS);
    }

    // 5) Fetch + parse
    async function fetchCoords(url) {
      const res = await fetch(url + '&t=' + Date.now(), { cache:'no-cache' });
      if (!res.ok) throw new Error(res.statusText);
      const txt = await res.text();
      return parseCSV(txt);
    }

    // 6) At­naujinimo logika
    async function updateRoutes() {
      try {
        const [c1,c2] = await Promise.all([
          fetchCoords(CSV_GPS1),
          fetchCoords(CSV_GPS2)
        ]);

        // tik atnaujiname koordinates, NIEKUR NEBRAIŽOME NAUJŲ
        poly1.setLatLngs(c1);
        poly2.setLatLngs(c2);

        // ir sutankiname per bounds, bet ne mažiau nei zoom:3 ir ne daugiau nei zoom:12
        const all = c1.concat(c2);
        if (all.length) {
          map.fitBounds(L.latLngBounds(all), { 
            maxZoom: 12,   // nenorime išsilaužt žemyn iki zoom=0
            padding: [20,20]
          });
        }
      } catch (e) {
        console.error('Klaida kraunant GPS duomenis:', e);
      }
    }

    // 7) Paleidimas ir intervalas
    updateRoutes();
    setInterval(updateRoutes, REFRESH_MS);
  });
  </script>
</body>
</html>
